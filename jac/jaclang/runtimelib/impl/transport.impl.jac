"""Transport abstraction layer implementations."""

"""Create a success response with envelope pattern."""
impl TransportResponse.success(
    data: Any = None,
    msg_type: MessageType = MessageType.RESPONSE,
    meta: (Meta | None) = None
) -> TransportResponse {
    final_meta = meta or Meta();
    response = TransportResponse();
    response.type = msg_type.value if isinstance(msg_type, MessageType) else msg_type;
    response.ok = True;
    response.data = data;
    response.error = None;
    response.meta = final_meta;
    return response;
}

"""Create an error response with envelope pattern."""
impl TransportResponse.fail(
    code: str,
    message: str,
    details: Any = None,
    msg_type: MessageType = MessageType.ERROR,
    meta: (Meta | None) = None
) -> TransportResponse {
    final_meta = meta or Meta();
    response = TransportResponse();
    response.type = msg_type.value if isinstance(msg_type, MessageType) else msg_type;
    response.ok = False;
    response.data = None;
    response.error = ErrorInfo(code=code, message=message, details=details);
    response.meta = final_meta;
    return response;
}

"""HTTP is stateless - nothing to connect."""
impl HTTPTransport.connect -> None {
# Nothing to do for stateless HTTP
}

"""Serialize and send HTTP response. Converts TransportResponse to HTTP format."""
impl HTTPTransport.send(data: Any) -> None {
    if isinstance(data, TransportResponse) {
        # Extract HTTP status from meta.extra or use defaults
        status = data.meta.extra.get('http_status', 200 if data.ok else 500) if data.meta.extra else (200 if data.ok else 500);

        # Build response body
        response_body = {
            'ok': data.ok,
            'type': data.type
        };

        if data.ok and (data.data is not None) {
            # For success responses, include data directly at root level for backward compatibility
            if isinstance(data.data, <>dict) {
                response_body.update(data.data);
            } else {
                response_body['data'] = data.data;
            }
        }

        if not data.ok and data.error {
            # Serialize ErrorInfo object
            if hasattr(data.error, 'message') {
                response_body['error'] = data.error.message;
            }
            if hasattr(data.error, 'code') and data.error.code {
                response_body['code'] = data.error.code;
            }
            if hasattr(data.error, 'details') and (data.error.details is not None) {
                response_body['details'] = data.error.details;
            }
        }

        # Send HTTP response
        self.handler.send_response(status);
        self.handler.send_header('Content-Type', 'application/json');
        self.handler.send_header('Access-Control-Allow-Origin', '*');
        self.handler.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
        self.handler.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
        self.handler.end_headers();
        self.handler.wfile.write(json.dumps(response_body).encode());

        # Store for any callbacks
        self.response_data = response_body;
    } else {
        # For non-TransportResponse data (backward compatibility)
        self.response_data.update(data) if isinstance(data, <>dict) else None;
        self.response_data = data if not isinstance(data, <>dict) else self.response_data;
    }

    # Trigger on_message callback if registered
    if self.on_message {
        self.on_message(data);
    }
}

"""HTTP is stateless - nothing to close."""
impl HTTPTransport.close -> None {
# Nothing to do for stateless HTTP
}

"""SSE is stateless - nothing to connect."""
impl StreamTransport.connect -> None {
# Nothing to do for SSE
}

"""Push data to the queue for SSE streaming."""
impl StreamTransport.send(data: Any) -> None {
    import asyncio;
    # Queue.put is async, so we need to handle it properly
    # In real usage, this would be: await self.queue.put(data)
    try {
        self.queue.put_nowait(data);
    } except Exception as e {
        if self.on_error {
            self.on_error(e);
        }
    }
}

"""Signal stream end by pushing None to queue."""
impl StreamTransport.close -> None {
    try {
        self.queue.put_nowait(None);
    } except Exception as e {
        if self.on_error {
            self.on_error(e);
        }
    }
    if self.on_close {
        self.on_close();
    }
}

"""Accept the WebSocket connection."""
impl WebSocketTransport.connect -> None {
# In real async usage: await self.websocket.accept()
# For now, assume websocket is already accepted
}

"""Send JSON data through WebSocket."""
impl WebSocketTransport.send(data: Any) -> None {
    # In real async usage: await self.websocket.send_json(data)
    try {
        json_data = json.dumps(data);
        # Placeholder for actual websocket send
        if self.on_message {
            self.on_message(data);
        }
    } except Exception as e {
        if self.on_error {
            self.on_error(e);
        }
    }
}

"""Close the WebSocket connection."""
impl WebSocketTransport.close -> None {
    # In real async usage: await self.websocket.close()
    if self.on_close {
        self.on_close();
    }
}

"""Run the processor - demonstrates the architecture pattern."""
impl MessageProcessor.run -> None {
    try {
        # Connect through the transport (could be HTTP, WS, SSE, etc.)
        # await self.transport.connect()
        self.transport.connect();

        # Send initial status - works with ANY transport
        # await self.transport.send({"status": "connected"})
        self.transport.send({"status": "connected"});

        # Process some data
        # await self.process_message({"action": "hello"})
        self.process_message({"action": "hello"});
    } except Exception as e {
        if self.transport.on_error {
            self.transport.on_error(e);
        }
    }
}

"""Process a message - transport-agnostic business logic."""
impl MessageProcessor.process_message(data: dict[(str, Any)]) -> None {
    # Business logic here - doesn't know about HTTP/WS/SSE
    result = {"processed": True, "received": data, "timestamp": "2026-01-09T00:00:00Z"};
    # Send result through transport - protocol-agnostic!
    # await self.transport.send(result)
    self.transport.send(result);
}
